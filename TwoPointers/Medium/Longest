import java.util.HashMap;

/*
========================================================
Problem Statement:
Given a string s and an integer k,
find the length of the longest substring 
with exactly k distinct characters.

If no such substring exists, return -1.
========================================================
*/

public class LongestKSubstr {

    /*
    ========================================================
    üß† INTUITION:

    We need longest substring with EXACTLY k distinct chars.

    Key idea:
    - Use Sliding Window (Two Pointers)
    - Expand window using right pointer (r)
    - Shrink window using left pointer (l)
    - Maintain frequency using HashMap
    - When distinct characters exceed k ‚Üí shrink window
    - When distinct == k ‚Üí update answer

    Pattern: Variable size sliding window
    ========================================================
    */

    // -----------------------------------------------------
    // 1Ô∏è‚É£ BRUTE FORCE APPROACH
    // -----------------------------------------------------
    /*
    Idea:
    - Generate all substrings
    - For each substring, count distinct characters
    - Track maximum length where distinct == k

    Time Complexity: O(n^3)
        - O(n^2) substrings
        - O(n) to count distinct

    Space Complexity: O(k)
    */

    public static int bruteForce(String s, int k) {

        int max = -1;

        for (int i = 0; i < s.length(); i++) {
            for (int j = i; j < s.length(); j++) {

                HashMap<Character, Integer> map = new HashMap<>();

                for (int x = i; x <= j; x++) {
                    map.put(s.charAt(x),
                            map.getOrDefault(s.charAt(x), 0) + 1);
                }

                if (map.size() == k) {
                    max = Math.max(max, j - i + 1);
                }
            }
        }
        return max;
    }

    // -----------------------------------------------------
    // 2Ô∏è‚É£ BETTER / OPTIMAL APPROACH (Sliding Window)
    // -----------------------------------------------------
    /*
    Idea:
    - Expand window using r
    - Add characters into map
    - If map.size() > k ‚Üí shrink window
    - If map.size() == k ‚Üí update max

    Time Complexity: O(n)
        Each character visited at most twice
        (once by r and once by l)

    Space Complexity: O(k)
        At most k distinct characters in map
    */

    public static int optimal(String s, int k) {

        int max = -1;
        int l = 0;

        HashMap<Character, Integer> map = new HashMap<>();

        for (int r = 0; r < s.length(); r++) {

            char ch = s.charAt(r);
            map.put(ch, map.getOrDefault(ch, 0) + 1);

            // shrink window if distinct > k
            while (map.size() > k) {

                char leftChar = s.charAt(l);
                map.put(leftChar, map.get(leftChar) - 1);

                if (map.get(leftChar) == 0)
                    map.remove(leftChar);

                l++;
            }

            // update max only when EXACTLY k distinct
            if (map.size() == k) {
                max = Math.max(max, r - l + 1);
            }
        }

        return max;
    }

    // -----------------------------------------------------
    // Main Method (for testing)
    // -----------------------------------------------------
    public static void main(String[] args) {

        String s = "aabacbebebe";
        int k = 3;

        System.out.println("Brute Force: " + bruteForce(s, k));
        System.out.println("Optimal: " + optimal(s, k));
    }
}